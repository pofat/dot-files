#!/bin/bash

# check repo.
if [ ! -d "${MDX_REPOS_ROOT}/fzf" ]; then
  printf "\e[33mneed [fzf], installing ...\e[0m\n"
  git clone "https://github.com/junegunn/fzf.git" \
    "${MDX_REPOS_ROOT}/fzf"
fi

export FZF_COMPLETION_TRIGGER=',,'
export FZF_COMPLETION_OPTS='-x'

# Setup fzf function
unalias fzf 2> /dev/null
fzf() {
  /usr/bin/ruby "${MDX_REPOS_ROOT}/fzf/fzf" "$@"
}
export -f fzf > /dev/null

# ^Tf to append file & paths under $(pwd) to the command line. {{{1
__fsel() {
  set -o nonomatch
  command find ./* -path '*/\.*' -prune \
    -o -type f -print \
    -o -type d -print \
    -o -type l -print 2> /dev/null | fzf -m -e | while read item; do
  printf '%q ' "$item"
done
echo
}

if [ -n "$TMUX_PANE" -a "${FZF_TMUX:-1}" -ne 0 -a "${LINES:-40}" -gt 15 ]; then
  fzf-file-widget() {
    local height
    height=${FZF_TMUX_HEIGHT:-40%}
    if [[ $height =~ %$ ]]; then
      height="-p ${height%\%}"
    else
      height="-l $height"
    fi
    tmux split-window "${height}" "zsh -c 'source ~/.fzf.zsh; tmux send-keys -t ${TMUX_PANE} \"\$(__fsel)\"'"
  }
else
  fzf-file-widget() {
    LBUFFER="${LBUFFER}$(__fsel)"
    zle redisplay
  }
fi

zle     -N   fzf-file-widget
bindkey '^Tf' fzf-file-widget
# }}}1

# ^Th - Paste the selected command from history into the command line. {{{1
fzf-history-widget() {
  LBUFFER=$(fc -l 1 | fzf +s +m -x -n2..,.. | sed "s/ *[0-9*]* *//")
  zle redisplay
}

zle     -N   fzf-history-widget
bindkey '^Th' fzf-history-widget
# }}}1

# ^Tz to append paths from $(z -l) to the command line. {{{1
__zdirs() {
  set -o nonomatch
  z -l | sed 's/[0-9.,]* *//' | fzf -m -e | while read item; do
  printf '%q ' "$item"
done
echo
}

mudox-zsh-widget-zdirs() {
  LBUFFER="${LBUFFER}$(__zdirs)"
  zle redisplay
}

zle     -N   mudox-zsh-widget-zdirs
bindkey '^Tz' mudox-zsh-widget-zdirs
# }}}1

# ^[j to cd to one of the paths in $(z -l). {{{1
mudox-zsh-widget-j() {
  if [[ -z "$(whence z)" ]]; then
    printf "\e[31mneed z, quit...\e[0m\n"
  fi

  local target_dir
  target_dir=$( z -l | sed 's/[0-9.,]* *//' | fzf +m \
    --select-1 \
    --exit-0 \
    --extended-exact)

  [ -n "$target_dir" ] && cd "$target_dir"

  zle reset-prompt
}

zle -N mudox-zsh-widget-j
bindkey '^[j' mudox-zsh-widget-j
#}}}1

# ^[c to cd to one of directory under current path. {{{1
# do not descend into hidden directories.
mudox-zsh-widget-c() {
  local target_dir
  target_dir=$(find ./* -path '*/\.*' -prune \
    -o -type d -print 2> /dev/null | \
    fzf +m +s --extended-exact)

  [ -n "$target_dir" ] && cd "$target_dir"

  zle reset-prompt
}

zle -N mudox-zsh-widget-c
bindkey '^[c' mudox-zsh-widget-c
#}}}1

# fe [pattern] to open the selected file with the gvim in tab. {{{1
fe() {
  local file
  file=$(fzf \
    --query="$1" \
    --select-1 \
    --exit-0 \
    --extended-exact \
    --prompt="open in gvim tab: ")

  case $(uname -s) in
    Darwin )
      # for MacOS
      if whence nvim; then
	local vim_bin='nvim'
      else
	local vim_bin='mvim'
      fi
      ;;
    CYGWIN* )
      # for Cygwin on Windows
      local vim_bin="/d/Program Files/Vim/vim74/vim_bin.exe"
      ;;
    Linux )
      # for Linux
      local vim_bin="vim_bin"
      ;;
    * )
      printf "\e[31m[.zshrc]: un-recognized platform.\n"
      ;;
  esac

  if [[ "${vim_bin}" = "nvim" ]]; then
    #statements
    [ -n "$file" ] && "${vim_bin}" "$file"
  else
    [ -n "$file" ] && "${vim_bin}" --remote-tab-silent "$file"
  fi
} #}}}1

# fkill to select & kill procces. {{{1
fkill() {
  ps | \
    sed '1d' | \
    fzf --multi --extended-exact | \
    awk '{print $2}' | \
    xargs kill -"${1:-9}"
} #}}}1

# cmake help selection. {{{1

# cmake helps {{{2
cmh() {
  local category
  local usage="\
    usage: $0 <c|ma|mo|po|pr|v> [selection]
  where
  c  - command
  ma - manual
  mo - module
  po - policy
  pr - property
  v  - variable"

  if [[ "$#" -eq 0 ]]; then
    local categories="command\nmanual\nmodule\npolicy\nproperty\nvariable"

    category=$(echo ${categories} | fzf \
      --query="$2"                      \
      --select-1                        \
      --extended-exact                  \
      --prompt="cmake help category: ")

    if [[ -z "${category}" ]]; then
      return
    fi
  else
    case "$1" in
      c )
	category="command"
	;;
      ma )
	category="manual"
	;;
      mo )
	category="module"
	;;
      po )
	category="policy"
	;;
      pr )
	category="property"
	;;
      v )
	category="variable"
	;;
      * )
	printf "\e[31m%s: invalid first argument\e[0m\n" "$0"
	echo "${usage}"
	return
	;;
    esac
  fi

  local selection
  selection=$(cmake --help-${category}-list | \
    sed '1d' | sort | uniq |              \
    fzf                                   \
    --query="$2"                          \
    --select-1                            \
    --extended-exact                      \
    --prompt="cmake help ${category}: ")
  if [[ -n "${selection}" ]]; then
    cmake "--help-${category}" "${selection}" | less
  fi
}
# }}}2

# ctest helps {{{2
# NOTE: just a copy of cmh() above, with all 'cmake' replaced with 'ctest'.
cth() {
  local category
  local usage="\
    usage: $0 <c|ma|mo|po|pr|v> [selection]
  where
  c  - command
  ma - manual
  mo - module
  po - policy
  pr - property
  v  - variable"

  if [[ "$#" -eq 0 ]]; then
    local categories="command\nmanual\nmodule\npolicy\nproperty\nvariable"

    category=$(echo ${categories} | fzf \
      --query="$2"                      \
      --select-1                        \
      --extended-exact                  \
      --prompt="ctest help category: ")

    if [[ -z "${category}" ]]; then
      return
    fi
  else
    case "$1" in
      c )
	category="command"
	;;
      ma )
	category="manual"
	;;
      mo )
	category="module"
	;;
      po )
	category="policy"
	;;
      pr )
	category="property"
	;;
      v )
	category="variable"
	;;
      * )
	printf "\e[31m%s: invalid first argument\e[0m\n" "$0"
	echo "${usage}"
	return
	;;
    esac
  fi

  local selection
  selection=$(ctest --help-${category}-list | \
    sed '1d' | sort | uniq |              \
    fzf                                   \
    --query="$2"                          \
    --select-1                            \
    --extended-exact                      \
    --prompt="ctest help ${category}: ")

  if [[ -n "${selection}" ]]; then
    ctest "--help-${category}" "${selection}" | less
  fi
}
# }}}2

# }}}1

# (neo)vim mode set {{{1
vmode() {
  local modes_path="${MDX_REPOS_ROOT}/vim-config/chameleon/modes"
  local cur_mode_file="${modes_path}/../cur_mode"

  local selection
  selection=$(                              \
    ls -1 "${modes_path}" | grep -v '^x_' | \
    fzf                                     \
      --extended-exact                      \
      --select-1                            \
      --prompt='change (neo)vim mode: '     \
  )

  if [[ -n "${selection}" ]]; then
    echo "${selection}" > "${cur_mode_file}"
  fi

  printf "\e[33mset new mode to [$(cat ${cur_mode_file})]\e[0m\n"
}

# }}}1

# vim: filetype=zsh foldmethod=marker
